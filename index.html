<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>A-Frame Maze</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
  <script src="goal.js"></script>
  <script src="target-spawner.js"></script>
  
  <script src="score-manager.js"></script>
  <script src="score-display.js"></script>
  <script src="shoot_countDown.js"></script>
  <script src="target-life.js"></script>

  <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v7.2.0/dist/aframe-extras.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/aframe-msdf-text-component/dist/aframe-msdf-text-component.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; }
  </style>

</head>
<body>

<a-scene>
  <a-assets>
    <a-asset-item id="cork" src="cork.glb"></a-asset-item><!--ã‚³ãƒ«ã‚¯-->
    <a-asset-item id="kabe2" src="wall.glb"></a-asset-item><!--å£-->
    <a-asset-item id="yuka" src="tile.glb"></a-asset-item><!--åºŠ-->
    <a-asset-item id="goal" src="start.glb"></a-asset-item><!--ã‚´ãƒ¼ãƒ«-->
    <a-asset-item id="timer" src="timer.glb"></a-asset-item>
    <a-asset-item id="mato" src="mato.glb"></a-asset-item>
    <a-asset-item id="map" src="ku-kan.glb"></a-asset-item>
  </a-assets>
  <a-sky color="black"></a-sky><!--ç©ºã®è‰²-->
  <!-- ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®š -->
  <a-entity id="rig"
    movement-control
    arrival-check="destination: 31 1.6 35; onarrival: 100 50 100"
    vr-stick-move
    vr-trigger-shoot
    position="3 1.6 10">
    <!-- ã‚«ãƒ¡ãƒ©ã®è¨­å®šï¼ˆæ„Ÿåº¦ãªã©ï¼‰ -->
    <a-entity id="camera"
      camera
      mouse-look="sensitivity: 0.1"
      cork-shooter
      position="0 0 0"
      score-display="hudSelector: #scoreHud">
      <!-- ã‚¿ã‚¤ãƒãƒ¼ -->
      <a-plane position="0 -0.5 -1.21" width="1.2" height="0.4" color="#000" opacity="0.5" material="shader: flat"></a-plane>
      <a-entity id="timerText" text="value: 60; color: red; align: center" width: 3 scale="2 2 2" position="0 -0.5 -1.2"></a-entity>
      <!-- ã‚¯ãƒ­ã‚¹ãƒ˜ã‚¢ -->
      <a-entity id="crosshair"
                geometry="primitive: ring; radiusInner: 0.002; radiusOuter: 0.004"
                material="color: red; shader: flat"
                position="0 0 -1">
      </a-entity>
      <!--æ®‹å¼¾æ•°-->
      <a-entity id="ammoHud"
            text="value: ammo: 10; color: red; align: left; shader: msdf"
            position="-0.4 -0.6 -1"
            scale="1 1 1">
      </a-entity>
      <!-- ã‚¹ã‚³ã‚¢è¡¨ç¤º -->
      <a-entity id="scoreHud"
          text="value: score: 0; color: yellow; align: right; shader: msdf"
          position="0.4 -0.6 -1"
          scale="1 1 1">
      </a-entity>
      <a-entity id="countdown" 
        shoot-countdown="time: 3">
      </a-entity>

      <a-entity id="rightHand"
        oculus-touch-controls="hand: right; model: true"
        laser-controls="hand: right">
      </a-entity>
      <a-entity id="leftHand"
        oculus-touch-controls="hand: left; model: true"
        laser-controls="hand: left">
      </a-entity>



    </a-entity>
    <a-entity oculus-touch-controls="hand: right; model: true;" laser-controls="hand: right"></a-entity>
    <a-entity oculus-touch-controls="hand: left; model: true;" laser-controls="hand: left"></a-entity>
  </a-entity>

  <a-entity gltf-model="#map"
    position = "100 40 100"
    scale = "3 3 3"
  ></a-entity>


  <a-entity id="maze"></a-entity>
  <a-entity gltf-model="#goal" position="31 0.6 35" scale="0.5 1.3 0.5" rotation="0 90 0"></a-entity>

  <!-- ã‚¹ã‚³ã‚¢ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ï¼ˆã‚·ãƒ¼ãƒ³ç›´ä¸‹ã«é…ç½®ï¼‰ -->
  <a-entity id="scoreManager" score-manager></a-entity>

  <!-- ã‚¹ãƒãƒŠãƒ¼ï¼ˆãƒ†ãƒ¬ãƒãƒ¼ãƒˆå…ˆã®ä»˜è¿‘ã§è‡ªå‹•èµ·å‹•ï¼‰ -->
  <a-entity id="targetSpawner"
    target-spawner="center: 100 50 100;
    totalTargets: 12;
    duration: 20;
    radiusMin: 15;
    radiusMax: 35;
    heightMin: 50;
    heightMax: 60;">
  </a-entity>

</a-scene>

<div style="position: fixed; bottom: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; font-family: sans-serif; font-size: 14px; z-index: 1000;">
  ğŸ’¡ ç”»é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¦–ç‚¹æ“ä½œã‚’é–‹å§‹<br>
  ãƒã‚¦ã‚¹ã§è¦–ç‚¹ç§»å‹• / WASDã‚­ãƒ¼ã§ç§»å‹• / ESCã‚­ãƒ¼ã§çµ‚äº†
</div>

<script> 
  //1è¡Œä¸‹ã®æ–‡ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã§å‹•ãå¿…è¦ãŒã‚ã‚‹ãŸã‚25è¡Œãã‚‰ã„ä¸‹ã®<script type="module">ã®å‰ã«æ›¸ã 
  AFRAME.registerComponent("distance-check", { 
    //schema ã¯ã€ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã«å¯¾ã—ã¦ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ï¼ˆè¨­å®šé …ç›®ï¼‰ã‚’å®šç¾©ã™ã‚‹ãŸã‚ã«ä½¿ã† 
    schema: { 
    range: { type: "number", default: 0.5 },  // å–å¾—è·é›¢ 
    isEnabled: { type: "boolean", default: true } // ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æœ‰åŠ¹/ç„¡åŠ¹ãƒ•ãƒ©ã‚° 
  }, 
    tick: function () { 
      //ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãŒç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å‡¦ç†ã‚’çµ‚äº† 
      if(!this.data.isEnabled) return; 

      const item = this.el; 
      const rig = document.querySelector("#rig"); 

      if (!rig) return; 

      //ãƒªã‚°ã®ä¸­ã«ã‚«ãƒ¡ãƒ©ã‚’ä»˜å±ï¼ˆã¤ã¾ã‚Šãƒªã‚°ã«ã‚«ãƒ¡ãƒ©ãŒã²ã£ã¤ã„ã¦ãŠã‚Šã€ã‚«ãƒ¡ãƒ©ã®åº§æ¨™è‡ªä½“ã¯å›ºå®šï¼‰ã—ã¦ã„ã‚‹ã®ã§ã€ãƒªã‚°ã®ä½ç½®ã‚’å–å¾—ã™ã‚‹ 
      const rigPos = rig.object3D.position;//ãƒªã‚°ã®ä½ç½®å–å¾— 
      const itemPos = item.object3D.position;//ã‚¢ã‚¤ãƒ†ãƒ ã®ä½ç½®å–å¾— 
      const distance = itemPos.distanceTo(rigPos);//ã‚¢ã‚¤ãƒ†ãƒ ã¨ã‚«ãƒ¡ãƒ©ã®è·é›¢ã‚’è¨ˆç®— 

      console.log("ãƒªã‚°ã®ä½ç½®: ",rigPos); // ãƒªã‚°ã®ä½ç½®ã‚’ãƒ­ã‚°å‡ºåŠ› 
      console.log(`ã‚¢ã‚¤ãƒ†ãƒ ã¨ã®è·é›¢: ${distance}`); // è·é›¢ã‚’ãƒ­ã‚°å‡ºåŠ› 

      //ã€Œrangeã€ã‚’ä½¿ç”¨ã—ã¦ã‚¢ã‚¤ãƒ†ãƒ ã¨è‡ªåˆ†ï¼ˆãƒªã‚°ï¼‰ã®è·é›¢ãŒæŒ‡å®šä»¥ä¸‹ã¾ã§è¿‘ã¥ã„ãŸã¨ã 
      if (distance < this.data.range) { 

        //windowã‚’ã¤ã‘ã‚‹ã¨ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«ãªã‚Šã€ã»ã‹ã®é–¢æ•°ã§å®šç¾©ã•ã‚ŒãŸå¤‰æ•°ã‚’ä½¿ç”¨ã§ãã‚‹ 
        window.shot_time += 3; 

        item.parentNode.removeChild(item);//ã‚¢ã‚¤ãƒ†ãƒ ã®å‰Šé™¤ 
        //item.removeAttribute('distance-check'); // æ—¢å­˜ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’å‰Šé™¤ 
        //distance-checkã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®enabledå±æ€§ã‚’falseã«è¨­å®šã™ã‚‹æ–¹æ³• 
        this.el.setAttribute("distance-check", "isEnabled", false);//1ã‚¢ã‚¤ãƒ†ãƒ ï¼‘å›ã®ã¿å–å¾—åˆ¤å®šã‚’è¡Œã†ãŸã‚ï½ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ 
      } 
    } 
  }); 
  </script> 
 
<script type="module">
// ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯å¯¾å¿œã®ãƒã‚¦ã‚¹è¦–ç‚¹ç§»å‹•ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
AFRAME.registerComponent('mouse-look', {
  schema: {
    sensitivity: {type: 'number', default: 0.8},
    enabled: {type: 'boolean', default: true}
  },
 
  init: function () {
    this.yaw = 0;
    this.pitch = 0;
 
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onClick = this.onClick.bind(this);
    this.onPointerLockChange = this.onPointerLockChange.bind(this);
 
    // ã‚¯ãƒªãƒƒã‚¯ã§ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ã‚’è¦æ±‚
    document.addEventListener('click', this.onClick);
    document.addEventListener('pointerlockchange', this.onPointerLockChange);
    document.addEventListener('mozpointerlockchange', this.onPointerLockChange);
    document.addEventListener('webkitpointerlockchange', this.onPointerLockChange);
  },
 
  onClick: function () {
    // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ãƒ­ãƒƒã‚¯ã‚’è¦æ±‚
    const canvas = document.querySelector('canvas');
    if (canvas && canvas.requestPointerLock) {
      canvas.requestPointerLock = canvas.requestPointerLock ||
                                  canvas.mozRequestPointerLock ||
                                  canvas.webkitRequestPointerLock;
      canvas.requestPointerLock();
    }
  },
 
  onPointerLockChange: function () {
    const locked = document.pointerLockElement ||
                   document.mozPointerLockElement ||
                   document.webkitPointerLockElement;
 
    if (locked) {
      document.addEventListener('mousemove', this.onMouseMove);
    } else {
      document.removeEventListener('mousemove', this.onMouseMove);
    }
  },
 
  onMouseMove: function (e) {
    if (!this.data.enabled) return;
 
    const movementX = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
    const movementY = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
 
    this.yaw -= movementX * this.data.sensitivity;
    this.pitch -= movementY * this.data.sensitivity;
 
    // ä¸Šä¸‹è¦–ç‚¹ã®åˆ¶é™ï¼ˆ-90åº¦ã‹ã‚‰90åº¦ï¼‰
    this.pitch = Math.max(-90, Math.min(90, this.pitch));
 
    this.el.setAttribute('rotation', {
      x: this.pitch,
      y: this.yaw,
      z: 0
    });
  },
 
  remove: function () {
    document.removeEventListener('click', this.onClick);
    document.removeEventListener('mousemove', this.onMouseMove);
    document.removeEventListener('pointerlockchange', this.onPointerLockChange);
    document.removeEventListener('mozpointerlockchange', this.onPointerLockChange);
    document.removeEventListener('webkitpointerlockchange', this.onPointerLockChange);
  }
});

  import './CorkFromTheEye.js';

  AFRAME.registerComponent('movement-control', {
  init: function () {
    this.velocity = new THREE.Vector3();
    this.direction = new THREE.Vector3();
    this.speed = 0.1;
    
    this.keys = {};
    window.addEventListener('keydown', (e) => {
      this.keys[e.code] = true;
    });
    window.addEventListener('keyup', (e) => {
      this.keys[e.code] = false;
    });
  },
  
  tick: function () {
  const el = this.el;
  let pos = el.getAttribute('position');

  const camera = el.querySelector('[camera]');
  const cameraRotation = camera.getAttribute('rotation');
  const angleY = THREE.MathUtils.degToRad(cameraRotation.y);

  this.direction.set(0, 0, 0);

  if (this.keys['KeyW'] || this.keys['ArrowUp']) {
    this.direction.x -= Math.sin(angleY);
    this.direction.z -= Math.cos(angleY);
  }
  if (this.keys['KeyS'] || this.keys['ArrowDown']) {
    this.direction.x += Math.sin(angleY);
    this.direction.z += Math.cos(angleY);
  }
  if (this.keys['KeyA'] || this.keys['ArrowLeft']) {
    this.direction.x -= Math.cos(angleY);
    this.direction.z += Math.sin(angleY);
  }
  if (this.keys['KeyD'] || this.keys['ArrowRight']) {
    this.direction.x += Math.cos(angleY);
    this.direction.z -= Math.sin(angleY);
  }

  if (this.direction.length() > 0) {
    this.direction.normalize();
  }

  this.velocity.copy(this.direction).multiplyScalar(this.speed);

  const nextX = {
    x: pos.x + this.velocity.x,
    y: pos.y,
    z: pos.z
  };

  if (!this.checkWallCollision(nextX)) {
    pos.x = nextX.x;
  }

  const nextZ = {
    x: pos.x,
    y: pos.y,
    z: pos.z + this.velocity.z
  };

  if (!this.checkWallCollision(nextZ)) {
    pos.z = nextZ.z;
  }

  el.setAttribute('position', pos);
},
  
  checkWallCollision: function (position) {

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å½“ãŸã‚Šåˆ¤å®šï¼ˆç®±ï¼‰
    const playerBox = new THREE.Box3(
      new THREE.Vector3(position.x - 0.3, position.y - 1, position.z - 0.3),
      new THREE.Vector3(position.x + 0.3, position.y + 1, position.z + 0.3)
    );

    const walls = document.querySelectorAll('.wall-collision');

      for (let wall of walls) {
        const mesh = wall.getObject3D('mesh');
        if (!mesh) continue;

        const wallBox = new THREE.Box3().setFromObject(mesh);

        if (playerBox.intersectsBox(wallBox)) {
          console.log("HIT", wall);
          return true;
        }
      }
      return false;
  }

});

AFRAME.registerComponent('vr-stick-move', {
  schema: {
    speed: { default: 0.06 }
  },
 
  init: function () {
    this.dir = new THREE.Vector3();
  },
 
  tick: function () {
    const rig = this.el;
    const hand = document.querySelector('#rightHand');
    if (!hand) return;
 
    const controls = hand.components['oculus-touch-controls'];
    if (!controls || !controls.controller) return;
 
    const gamepad = controls.controller.gamepad;
    if (!gamepad || !gamepad.axes) return;
 
    // Questå³ã‚¹ãƒ†ã‚£ãƒƒã‚¯
    const x = gamepad.axes[2];
    const z = gamepad.axes[3];
 
    //ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³
    if (Math.abs(x) < 0.15 && Math.abs(z) < 0.15) return;
 
    const camera = rig.querySelector('[camera]');
    const rotY = THREE.MathUtils.degToRad(
      camera.getAttribute('rotation').y
    );
 
    this.dir.set(
      -Math.sin(rotY) * z + Math.cos(rotY) * x,
      0,
      -Math.cos(rotY) * z - Math.sin(rotY) * x
    ).normalize();
 
    const pos = rig.getAttribute('position');
 
    const nextX = { x: pos.x + this.dir.x * this.data.speed, y: pos.y, z: pos.z };
    if (!rig.components['movement-control'].checkWallCollision(nextX)) {
      pos.x = nextX.x;
    }
 
    const nextZ = { x: pos.x, y: pos.y, z: pos.z + this.dir.z * this.data.speed };
    if (!rig.components['movement-control'].checkWallCollision(nextZ)) {
      pos.z = nextZ.z;
    }
 
    rig.setAttribute('position', pos);
  }
});
 
AFRAME.registerComponent('vr-trigger-shoot', { //ãƒˆãƒªã‚¬ãƒ¼æ“ä½œã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
  init: function () {
    this.prevPressed = false;
  },
 
  tick: function () {
    const rightHand = document.querySelector('[oculus-touch-controls][hand="right"]');
    if (!rightHand) return;
 
    const controls = rightHand.components['oculus-touch-controls'];
    if (!controls || !controls.controller) return;
 
    const gamepad = controls.controller.gamepad;
    if (!gamepad) return;
 
    const pressed = gamepad.buttons[0].pressed; // ãƒˆãƒªã‚¬ãƒ¼
 
    // æŠ¼ã—ãŸç¬é–“ã ã‘
    if (pressed && !this.prevPressed) {
      this.fire();
    }
 
    this.prevPressed = pressed;
  },
 
  fire: function () {
    const camera = document.querySelector('#camera');
    if (!camera) return;
 
    const shooter = camera.components['cork-shooter'];
    if (shooter && shooter.shootCork) {
      shooter.shootCork(); // â† ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã¨å®Œå…¨ã«åŒã˜å‡¦ç†
    }
  }
});
 


import { createKabe } from "./createkabe.js";
import { createFloors } from "./floor.js";
import { putTimer } from "./putTimer.js";
import { startTimer } from './timer.js';

const mazeArray = [
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
  [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1],
  [1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1],
  [1,0,1,0,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1],
  [1,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1],
  [1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],
  [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1],
  [1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,1,1,1],
  [1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1],
  [1,0,1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,1,1],
  [1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1],
  [1,0,1,0,1,1,1,1,1,0,1,1,1,0,1,1,1,0,1],
  [1,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1],
  [1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1],
  [1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1],
  [1,0,1,1,1,0,1,0,1,1,1,0,1,0,1,0,1,0,1],
  [1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1],
  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
];

document.querySelector("a-scene").addEventListener("loaded", () => {
    const scene = document.querySelector("#maze");

    createKabe(scene, mazeArray);
    createFloors(scene, 19);

    startTimer();//ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆ

    console.log("Maze generated after assets loaded");
});

const itemPositions = [
      [3,1],[5,11],[13,7],[15,15],[17,5]
    ];
    //pos[0]ãŒxåº§æ¨™ã€pos[1]ãŒyåº§æ¨™
    itemPositions.forEach(pos => putTimer(pos[0], pos[1], '#timer'));

</script>
</body>
</html>